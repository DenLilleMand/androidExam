package examples2;

import org.andengine.engine.Engine;
import org.andengine.engine.camera.Camera;
import org.andengine.opengl.texture.TextureOptions;
import org.andengine.opengl.texture.atlas.bitmap.BitmapTextureAtlas;
import org.andengine.opengl.texture.atlas.bitmap.BitmapTextureAtlasTextureRegionFactory;
import org.andengine.opengl.texture.atlas.bitmap.BuildableBitmapTextureAtlas;
import org.andengine.opengl.texture.atlas.bitmap.source.IBitmapTextureAtlasSource;
import org.andengine.opengl.texture.atlas.buildable.builder.BlackPawnTextureAtlasBuilder;
import org.andengine.opengl.texture.atlas.buildable.builder.ITextureAtlasBuilder;
import org.andengine.opengl.texture.region.ITextureRegion;
import org.andengine.opengl.vbo.VertexBufferObjectManager;
import org.andengine.util.debug.Debug;

import niclas.kristian.matti.GameActivity;

/**
 * Created by herpderp on 27/05/2015.
 */
public class TextureFactory {

    private static TextureFactory instance = new TextureFactory();
    public Engine engine;
    public GameActivity activity;
    public Camera camera;
    public VertexBufferObjectManager vbom;
    public BuildableBitmapTextureAtlas bitmapTextureAtlas;
    public ITextureRegion rectangleOneTexture,rectangleTwoTexture,rectangleThreeTexture;

    private TextureFactory(){
        if(instance != null){
            throw new IllegalAccessError();
        }
    }

    public static TextureFactory getInstance(){
        return instance;
    }

    public static void prepareTextureFactory(Engine engine, GameActivity activity, Camera camera, VertexBufferObjectManager vbom){
        getInstance().engine = engine;
        getInstance().activity = activity;
        getInstance().camera = camera;
        getInstance().vbom = vbom;
    }

    public void loadTextures(){
        BitmapTextureAtlasTextureRegionFactory.setAssetBasePath("gfx/");
        //a texture atlas, is a object that has a surden size, and as such, can contain smaller sized,
        //textures, such as our 3 smaller rectangles_one/two/three in our /gfx assets.
        //1024,1024 is actually the maximum allowed amount of textures, we could specify it higher, but if the mobile
        //cannot handle it, we will obviously get an error, 1024 -1024 is fine though.
        /** Regarding this whole thing about TextureOptions BILINEAR:
         * AndEngine allows us to apply texture options and formats to our texture atlases. The various combination of options and formats applied to a texture atlas will affect the overall quality and performance impact that sprites have on our game. Of course, that is if the mentioned sprites are using
         ITextureRegion
         objects, which are related to the modied
         BitmapTextureAtlas
         atlas The base texture options available in AndEngine are as follows:

         Nearest: This texture option is applied to texture atlases by
         default. This is the fastest-performing texture option we can apply to a texture atlas,
         but also the poorest in quality. This option means that the texture will apply blending
         of pixels that make up the display by obtaining the nearest texel color to a pixel.
         Similar to how a pixel represents the smallest element of a digital image, a
         texel represents the smallest element of a texture.

         Bilinear:The second main texture Altering option in AndEngine is called bilinear texture ltering. This approach takes a hit performance-wise, but the quality of scaled sprites will increase. Bilinear ltering obtains the four nearest texels per pixel in order
         to provide smoother blending to an onscreen image.

         Repeating(for our slider?!?!) : The repeating texture option allows the sprite to "repeat"
         the texture assuming that the  ITextureRegion object's width and height has been exceeded
         by the size of the sprite. In most games, the terrain is usually generated by creating a
         repeating texture and stretching the size of the sprite, rather than creating many separate
         sprites to cover the ground.
         */
        this.bitmapTextureAtlas = new BuildableBitmapTextureAtlas(activity.getTextureManager(), 1024, 1024, TextureOptions.BILINEAR);
        //now that we have an atlas, when can make our ITextureRegions, and place them on top of the Atlas.
        // we get help from the BitmapTextureAtlasTextureRegionFactory, that helps us bind the .png images to the atlas.
        //The BuildableBitMapTextureAtlas, compare to just the BitMapTextureAtlas, is that we dont have to point
        //to the location of the .png texture we need, we just load it in, and load it out, so its like a minor ORM
        //system for textures.
        /** Let's take a look at how to create a repeating texture:
         /* Create our repeating texture. Repeating textures require width/height which are a power of two */
       /* BuildableBitmapTextureAtlas texture = new BuildableBitmapTexture Atlas(engine.getTextureManager(), 32, 32, TextureOptions.REPEATING_BILINEAR);
         // Create our texture region - nothing new here
        mSquareTextureRegion = BitmapTextureAtlasTextureRegionFactory.createFromAsset(texture, context, "square.png");
        try { // Repeating textures should not have padding
         texture.build(new BlackPawnTextureAtlasBuilder<IBitmapTextureAtlasSource, BitmapTextureAtlas>(0, 0, 0));
            texture.load();
        } catch (TextureAtlasBuilderException e) {
            Debug.e(e);
        }
        he previous code is based on a square image which is 32 x 32 pixels in dimension. Two things to keep in mind when creating repeating textures are as follows:

1
Texture atlases using the repeating texture option format require the power of two
dimensions (2, 4, 8, 16, and so on)

2
If you are using a buildable texture atlas, do not apply padding or spacing during the
build()
 method, as it will be taken into account in the repeating of the texture,
breaking the rst rule of repeating textures

When we have to use this we have to do something like this:
/* Increase the texture region's size, allowing repeating textures to stretch up to 800x480 */
       /* ResourceManager.getInstance().mSquareTextureRegion.setTextureSize(800, 480);
        // Create a sprite which stretches across the full screenSprite
         sprite = new Sprite(0, 0, 800, 480, ResourceManager.getInstance().mSquareTextureRegion, mEngine.getVertexBufferObjectManager());


        And then use that sprite(page 36 in the book).
*/

        rectangleOneTexture = BitmapTextureAtlasTextureRegionFactory.createFromAsset(bitmapTextureAtlas, activity, "rectangle_one.png");
        rectangleTwoTexture = BitmapTextureAtlasTextureRegionFactory.createFromAsset(bitmapTextureAtlas, activity, "rectangle_two.png");
        rectangleThreeTexture = BitmapTextureAtlasTextureRegionFactory.createFromAsset(bitmapTextureAtlas, activity, "rectangle_three.png");

        try
        {

            //last things we need is to build our textures into the atlas
            /**
             * Within the
             build(pTextureAtlasBuilder)
             method, we must provide a
             BlackPawnTextureAtlasBuilder
             class, dening three
             parameters. In this order, the parameters are
             pTextureAtlasBorderSpacing
             ,
             pTextureAtlasSourceSpacing
             , and
             pTextureAtlasSourcePadding
             . In the previous code snippet, we will remove the likelihood of texture bleeding
             in almost all cases. However, in extreme cases, if there is texture bleeding, then
             simply increase the third parameter, this will help to alleviate any issues.
             */
            this.bitmapTextureAtlas.build(new BlackPawnTextureAtlasBuilder<IBitmapTextureAtlasSource, BitmapTextureAtlas>(0, 1, 0));
            //And then load the atlas into our memory.
            this.bitmapTextureAtlas.load();
        }
        catch (final ITextureAtlasBuilder.TextureAtlasBuilderException e)
        {
            Debug.e(e);
        }
    }


}
